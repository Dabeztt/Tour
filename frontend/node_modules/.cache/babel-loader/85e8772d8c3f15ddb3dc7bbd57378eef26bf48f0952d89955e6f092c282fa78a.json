{"ast":null,"code":"/*!\n  * Bootstrap config.js v5.3.2 (https://getbootstrap.com/)\n  * Copyright 2011-2023 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('../dom/manipulator.js'), require('./index.js')) : typeof define === 'function' && define.amd ? define(['../dom/manipulator', './index'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Config = factory(global.Manipulator, global.Index));\n})(this, function (Manipulator, index_js) {\n  'use strict';\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/config.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n\n  /**\n   * Class definition\n   */\n  class Config {\n    // Getters\n    static get Default() {\n      return {};\n    }\n    static get DefaultType() {\n      return {};\n    }\n    static get NAME() {\n      throw new Error('You have to implement the static method \"NAME\", for each component!');\n    }\n    _getConfig(config) {\n      config = this._mergeConfigObj(config);\n      config = this._configAfterMerge(config);\n      this._typeCheckConfig(config);\n      return config;\n    }\n    _configAfterMerge(config) {\n      return config;\n    }\n    _mergeConfigObj(config, element) {\n      const jsonConfig = index_js.isElement(element) ? Manipulator.getDataAttribute(element, 'config') : {}; // try to parse\n\n      return {\n        ...this.constructor.Default,\n        ...(typeof jsonConfig === 'object' ? jsonConfig : {}),\n        ...(index_js.isElement(element) ? Manipulator.getDataAttributes(element) : {}),\n        ...(typeof config === 'object' ? config : {})\n      };\n    }\n    _typeCheckConfig(config) {\n      let configTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.constructor.DefaultType;\n      for (const [property, expectedTypes] of Object.entries(configTypes)) {\n        const value = config[property];\n        const valueType = index_js.isElement(value) ? 'element' : index_js.toType(value);\n        if (!new RegExp(expectedTypes).test(valueType)) {\n          throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\".`);\n        }\n      }\n    }\n  }\n  return Config;\n});","map":{"version":3,"mappings":";;;;;;;;;;EAAA;;;;;;;EAUA;;;EAIA,MAAMA,MAAM,CAAC;IACX;IACA,WAAWC,OAAOA,GAAG;MACnB,OAAO,EAAE;IACX;IAEA,WAAWC,WAAWA,GAAG;MACvB,OAAO,EAAE;IACX;IAEA,WAAWC,IAAIA,GAAG;MAChB,MAAM,IAAIC,KAAK,CAAC,qEAAqE,CAAC;IACxF;IAEAC,UAAUA,CAACC,MAAM,EAAE;MACjBA,MAAM,GAAG,IAAI,CAACC,eAAe,CAACD,MAAM,CAAC;MACrCA,MAAM,GAAG,IAAI,CAACE,iBAAiB,CAACF,MAAM,CAAC;MACvC,IAAI,CAACG,gBAAgB,CAACH,MAAM,CAAC;MAC7B,OAAOA,MAAM;IACf;IAEAE,iBAAiBA,CAACF,MAAM,EAAE;MACxB,OAAOA,MAAM;IACf;IAEAC,eAAeA,CAACD,MAAM,EAAEI,OAAO,EAAE;MAC/B,MAAMC,UAAU,GAAGC,kBAAS,CAACF,OAAO,CAAC,GAAGG,WAAW,CAACC,gBAAgB,CAACJ,OAAO,EAAE,QAAQ,CAAC,GAAG,EAAE,CAAC;;MAE7F,OAAO;QACL,GAAG,IAAI,CAACK,WAAW,CAACd,OAAO;QAC3B,IAAI,OAAOU,UAAU,KAAK,QAAQ,GAAGA,UAAU,GAAG,EAAE,CAAC;QACrD,IAAIC,kBAAS,CAACF,OAAO,CAAC,GAAGG,WAAW,CAACG,iBAAiB,CAACN,OAAO,CAAC,GAAG,EAAE,CAAC;QACrE,IAAI,OAAOJ,MAAM,KAAK,QAAQ,GAAGA,MAAM,GAAG,EAAE;OAC7C;IACH;IAEAG,gBAAgBA,CAACH,MAAM,EAA8C;MAAA,IAA5CW,WAAW,uEAAG,IAAI,CAACF,WAAW,CAACb,WAAW;MACjE,KAAK,MAAM,CAACgB,QAAQ,EAAEC,aAAa,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACJ,WAAW,CAAC,EAAE;QACnE,MAAMK,KAAK,GAAGhB,MAAM,CAACY,QAAQ,CAAC;QAC9B,MAAMK,SAAS,GAAGX,kBAAS,CAACU,KAAK,CAAC,GAAG,SAAS,GAAGE,eAAM,CAACF,KAAK,CAAC;QAE9D,IAAI,CAAC,IAAIG,MAAM,CAACN,aAAa,CAAC,CAACO,IAAI,CAACH,SAAS,CAAC,EAAE;UAC9C,MAAM,IAAII,SAAS,CAChB,GAAE,IAAI,CAACZ,WAAW,CAACZ,IAAI,CAACyB,WAAW,EAAG,aAAYV,QAAS,oBAAmBK,SAAiCJ,qCAAc,IAChI,CAAC;QACH;MACF;IACF;EACF","names":["Config","Default","DefaultType","NAME","Error","_getConfig","config","_mergeConfigObj","_configAfterMerge","_typeCheckConfig","element","jsonConfig","isElement","Manipulator","getDataAttribute","constructor","getDataAttributes","configTypes","property","expectedTypes","Object","entries","value","valueType","toType","RegExp","test","TypeError","toUpperCase"],"sources":["E:\\thieu nang viet code\\cnpm\\tour-management\\frontend\\node_modules\\bootstrap\\js\\src\\util\\config.js"],"sourcesContent":["/**\n * --------------------------------------------------------------------------\n * Bootstrap util/config.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nimport Manipulator from '../dom/manipulator.js'\nimport { isElement, toType } from './index.js'\n\n/**\n * Class definition\n */\n\nclass Config {\n  // Getters\n  static get Default() {\n    return {}\n  }\n\n  static get DefaultType() {\n    return {}\n  }\n\n  static get NAME() {\n    throw new Error('You have to implement the static method \"NAME\", for each component!')\n  }\n\n  _getConfig(config) {\n    config = this._mergeConfigObj(config)\n    config = this._configAfterMerge(config)\n    this._typeCheckConfig(config)\n    return config\n  }\n\n  _configAfterMerge(config) {\n    return config\n  }\n\n  _mergeConfigObj(config, element) {\n    const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, 'config') : {} // try to parse\n\n    return {\n      ...this.constructor.Default,\n      ...(typeof jsonConfig === 'object' ? jsonConfig : {}),\n      ...(isElement(element) ? Manipulator.getDataAttributes(element) : {}),\n      ...(typeof config === 'object' ? config : {})\n    }\n  }\n\n  _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {\n    for (const [property, expectedTypes] of Object.entries(configTypes)) {\n      const value = config[property]\n      const valueType = isElement(value) ? 'element' : toType(value)\n\n      if (!new RegExp(expectedTypes).test(valueType)) {\n        throw new TypeError(\n          `${this.constructor.NAME.toUpperCase()}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\".`\n        )\n      }\n    }\n  }\n}\n\nexport default Config\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}